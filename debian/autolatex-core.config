#!/usr/bin/perl -w
#
# summary of how this script can be called:
#        * <new-config> pre-install
#        * <new-config> pre-upgrade
#        * <new-config> configure
#        * <new-config> reconfigure
#        * <old-script> remove
#        * <old-script> upgrade
#
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

use strict;

use Debconf::Client::ConfModule ':all';
use File::Copy;

my $SCRIPT_DIRECTORY;
my $MAIN_DIRECTORY;
my $CONFIG_FILE;
my $CONFIG_FILE_MODEL;
my $PM_DIRECTORY;

BEGIN {
	$SCRIPT_DIRECTORY = '/usr/lib/autolatex';
	$CONFIG_FILE = "/etc/autolatex/config";
	$MAIN_DIRECTORY = "$SCRIPT_DIRECTORY/mkfiles";
	$CONFIG_FILE_MODEL = "$SCRIPT_DIRECTORY/default.cfg.model";
	$PM_DIRECTORY = "$SCRIPT_DIRECTORY/pm";
	push @INC, "$PM_DIRECTORY";
}

#--------------------------------------------------------------
# Print a message if in debug mode (see DEBCONF_DEBUG)
sub printDbg(@) {
	if (($ENV{'DEBCONF_DEBUG'})&&($ENV{'DEBCONF_DEBUG'} eq 'developer')) {
		print STDERR ("AutoLaTeX config: ",@_,"\n");
	}
	1;
}

#--------------------------------------------------------------
# Print an error message
sub printErr(@) {
	print STDERR (@_,"\n");
	1;
}

#--------------------------------------------------------------
# Debugging function
sub debugData(@) {
	stop();
	use Data::Dumper;
	die(Dumper(@_));
}

#--------------------------------------------------------------
# Main program

# Avoid stdout buffering
$|=1;

my @ret;
my $FRESH_INSTALL = 0;

printDbg("Running configuration script on ",$ARGV[0]);

if ($ARGV[0] eq "reconfigure") {
	# Make sure to show all the config pages on reconfigure
        fset("autolatex-core/intro-message","seen","true");
        set("autolatex-core/intro-message","true");
	fset("autolatex-core/auto-generation-imgs","seen","false");
	fset("autolatex-core/view-pdf-document","seen","false");
	fset("autolatex-core/makeindex-style","seen","false");
}
elsif ($ARGV[0] eq "pre-install") {
	# Make sure to show all the config pages on install
        fset("autolatex-core/intro-message","seen","false");
	fset("autolatex-core/auto-generation-imgs","seen","false");
	fset("autolatex-core/view-pdf-document","seen","false");
	fset("autolatex-core/makeindex-style","seen","false");
}
elsif ($ARGV[0] eq "pre-upgrade") {
	# Make sure to view the new configuration pages on upgrade
        #fset("autolatex-core/intro-message","seen","false");
	#fset("autolatex-core/makeindex-style","seen","false");
}
elsif ($ARGV[0] eq "remove") {
	# Remove the configuration file
	unlink("$CONFIG_FILE");
}

if (($ARGV[0] eq "configure")||(($ARGV[0] eq "reconfigure"))) {

	# Include the Perl packages that manage the AutoLaTeX structures
	printDbg('Inclusion paths: ', join(':',@INC));
	eval('use AutoLaTeX::Util qw/ isArray setAutoLaTeXInfo /;');
	die($@) if ($@);
	eval('use AutoLaTeX::Config;');
	die($@) if ($@);
	eval('use AutoLaTeX::Translator;');
	die($@) if ($@);

	setAutoLaTeXInfo("$0", "$0", "$SCRIPT_DIRECTORY");
	
	# Create the configuration file
	if ( ! -e "$CONFIG_FILE" ) {
		copy("$CONFIG_FILE_MODEL", "$CONFIG_FILE")
			or die("$CONFIG_FILE_MODEL: $!\n");
		# Make sure to show all the config pages on fresh install
	        fset("autolatex-core/intro-message","seen","false");
		fset("autolatex-core/auto-generation-imgs","seen","false");
		fset("autolatex-core/view-pdf-document","seen","false");
		fset("autolatex-core/makeindex-style","seen","false");
	}
	else {
		# Merge the old configuration file and the new one
		my %oldconfig = ();
		readConfigFile("$CONFIG_FILE",\%oldconfig,1);
		# Copy the model
		copy("$CONFIG_FILE_MODEL", "$CONFIG_FILE")
			or die("$CONFIG_FILE_MODEL: $!\n");
		# Get the new config
		my %newconfig = ();
		readConfigFile("$CONFIG_FILE",\%newconfig,1);
		# Force the values
		while (my ($attr,$attrvalue) = each(%oldconfig)) {
			$newconfig{"$attr"} = $attrvalue;
		}
		# Write the new configuration
		writeConfigFile("$CONFIG_FILE",\%newconfig);
	}

	# Read the configuration file and extract values for DebConf
	my %config = ();
	readConfigFile("$CONFIG_FILE",\%config,1);
	{
		my $value = cfgToBoolean(cfgBoolean($config{"generation.generate images"},1));
		printDbg("[Generation] generate images -> ",$value);
		set("autolatex-core/auto-generation-imgs", $value);

		if ($config{"generation.makeindex style"}) {
			if (isArray($config{"generation.makeindex style"})) {
				if ((@{$config{"generation.makeindex style"}} >= 2)&&
				    ($config{"generation.makeindex style"}[0] eq '@detect')&&
				    ($config{"generation.makeindex style"}[1] eq '@system')) {
					$value = "Auto-detection or System Default";
				}
				else {
					$value = "No MakeIndex style";
				}
			}
			elsif ($config{"generation.makeindex style"} eq '@system') {
				$value = "System Default only";
			}
			elsif ($config{"generation.makeindex style"} eq '@detect') {
				$value = "Auto-detection only";
			}
			# Only for ascendent compatibility
			elsif ($config{"generation.makeindex style"} eq '@detect@system') {
				$value = "Auto-detection or System Default";
			}
			else {
				$value = "No MakeIndex style";
			}
		}
		else {
			$value = "Auto-detection or System Default";
		}
		printDbg("[Generation] makeindex style -> ",$value);
		set("autolatex-core/makeindex-style",$value);

		$value = cfgToBoolean(cfgBoolean($config{"viewer.view"},0));
		printDbg("[Viewer] view -> ",$value);
		set("autolatex-core/view-pdf-document", $value);
	}

	if (($ENV{'DEBCONF_DEBUG'})&&($ENV{'DEBCONF_DEBUG'} eq 'developer')) {
		# Display the states of the configuration pages
		printDbg("view intro-message page -> ",fget("autolatex-core/intro-message","seen"));
		printDbg("view auto-generation-imgs page -> ",fget("autolatex-core/auto-generation-imgs","seen"));
		printDbg("view view-pdf-document page -> ",fget("autolatex-core/view-pdf-document","seen"));
		printDbg("view makeindex-style page -> ",fget("autolatex-core/makeindex-style","seen"));
	}

	# Do the DebConf wizard

	my $state = 1;

	settitle("autolatex-core/thetitle");
	
	while (1) {
		if ($state == 0) {
			# Allow the user to backup from image generation selection
			$state ++;
	                next;
		}
		elsif ($state == 1) {
			# Display to the remark about this wizard
			input("high","autolatex-core/intro-message");
		}
		elsif ($state == 2) {
			# Test if the user ask yes to the previous question
			if (get('autolatex-core/intro-message') eq 'true') {
				printDbg("displaying the configuration pages if never shown");
				$state ++;
		                next;			
			}
			else {
				printDbg("skipping the configuration pages");
				last;
			}
		}
		elsif ($state == 3) {
			# Display to the user the question about the automatic generation
			input("high","autolatex-core/auto-generation-imgs");
		}
		elsif ($state == 4) {
			fset("autolatex-core/auto-generation-imgs","seen","true");
			# Display to the user the question about the viewer launch
			input("high","autolatex-core/view-pdf-document");
		}
		elsif ($state == 5) {
			fset("autolatex-core/view-pdf-document","seen","true");
			# Display to the user the question about the makeindex style
			input("high","autolatex-core/makeindex-style");
		}
		else {
			fset("autolatex-core/makeindex-style","seen","true");
			last;
		}

		@ret = go();
		if ($ret[0]==0) {
			$state ++;
		}
		else {
			$state --;
		}
	}

	# Solve translator conflicts
	my %conflicts;
	{
		my %translators = getTranslatorList(\%config,0);
		if ($ARGV[0] eq "reconfigure") {
			reinitInclusionFlags(\%translators,\%config);
		}
		else {
			setInclusionFlags(\%translators,\%config);
		}
		%conflicts = detectConflicts(\%translators);
		%conflicts = ($conflicts{'system'}) ? %{$conflicts{'system'}} : ();
	}

	my %translatoranswers = ();
	if (%conflicts) {
		$state = 1;
		my $tmp;
		my @transsources = keys %conflicts;
		@transsources = sort @transsources;

		while (1) {
			my $problemindex = int(($state-1)/2);
			if ($state == 0) {
				# Allow the user to backup from first problem page
				$state = 1;
		                next;
			}
			elsif (($problemindex>=0)&&($problemindex<@transsources)) {
				my $questionstate = ((($state-1)%2) == 0);
				my $source = $transsources["$problemindex"];
				if ($questionstate) {
					# Display the question
					my @translatorlist = ();
					foreach $tmp (values %{$conflicts{"$source"}}) {
						push @translatorlist, $tmp->{'human-readable'}.
							' - '.$tmp->{'name'};
					}
			                fset("shared/autolatex-select-translator","seen","false");
					subst("shared/autolatex-select-translator","translatorlist",join(', ',@translatorlist));
					subst("shared/autolatex-select-translator","figuretype",".$source");
					@ret = input("critical","shared/autolatex-select-translator");
					if ($ret[0] != 0) {
						set("shared/autolatex-select-translator","");
					}
				}
				else {
					# Get the answer
					@ret = get("shared/autolatex-select-translator");
					if ($ret[0] == 0) {
						my $answer = $ret[1];
						$answer =~ /\s+\-\s+(.*?)$/;
						$answer = "$1";
						foreach $tmp (values %{$conflicts{"$source"}}) {
							my $name = $tmp->{'name'};
							$translatoranswers{"$name"} = cfgToBoolean("$name" eq "$answer");
						}
					}
					else {
						printErr("ERROR: unable to get the selected translator for $source from DebConf");
						stop();
						exit(1);
					}
				}
			}
			else {
				last;
			}

			@ret = go();
			if ($ret[0]==0) {
				$state ++;
			}
			else {
				$state --;
			}
		}
	}

	if (get('autolatex-core/intro-message') eq 'true') {
		# Check the value given by the user for the auto generation
		@ret = get("autolatex-core/auto-generation-imgs");
		if ($ret[0] == 0) {
			$config{'generation.generate images'} = cfgToBoolean(cfgBoolean($ret[1],0));
		}
		else {
			printErr("ERROR: unable to get the auto generation answer from DebConf: ",$ret[1]);
			stop();
			exit(1);
		}

		# Check the value given by the user for the viewer launching
		@ret = get("autolatex-core/view-pdf-document");
		if ($ret[0] == 0) {
			$config{'viewer.view'} = cfgToBoolean(cfgBoolean($ret[1],0));
		}
		else {
			printErr("ERROR: unable to get the viewer launching answer from DebConf: ",$ret[1]);
			stop();
			exit(1);
		}

		# Check the value given by the user for the makeindex style file
		@ret = get("autolatex-core/makeindex-style");
		if ($ret[0] == 0) {
			if ($ret[1] eq 'Auto-detection or System Default') {
				$config{'generation.makeindex style'} = ['@detect','@system'];
			}
			elsif ($ret[1] eq 'System Default only') {
				$config{'generation.makeindex style'} = '@system';
			}
			elsif ($ret[1] eq 'Auto-detection only') {
				$config{'generation.makeindex style'} = '@detect';
			}
			else {
				$config{'generation.makeindex style'} = '@none';
			}
		}
		else {
			printErr("ERROR: unable to get the makeindex style file answer from DebConf: ",$ret[1]);
			stop();
			exit(1);
		}
	}

	# Update the translator configurations
	while (my ($transname, $includetrans) = each(%translatoranswers)) {
		$config{"$transname.include module"} = cfgToBoolean(cfgBoolean($includetrans,0));
	}

	# Write the new configuration
	writeConfigFile("$CONFIG_FILE",\%config);
}

exit(0);
